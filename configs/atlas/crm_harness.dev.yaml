# Local smoke-test config that mirrors crm_harness.yaml but disables the LLM judge
# and limits token budgets for quick validation runs.

agent:
  type: crm_harness
  name: crm-benchmark-student-dev
  system_prompt: |
    You are the Arc CRM benchmark harness (dev). Execute the ground-truth conversation step-for-step.
  tools: []
  backend: postgres
  use_llm_judge: false

teacher:
  llm:
    provider: openai
    model: gpt-4.1
    api_key_env: OPENAI_API_KEY
    temperature: 0.05
    max_output_tokens: 1024

student:
  tool_choice: auto

orchestration:
  forced_mode: paired
  max_retries: 0

adaptive_teaching:
  enabled: false

rim:
  small_model:
    provider: openai
    model: gpt-4.1-mini
    api_key_env: OPENAI_API_KEY
    max_output_tokens: 512
  large_model:
    provider: openai
    model: gpt-4.1
    api_key_env: OPENAI_API_KEY
    max_output_tokens: 768
  judge_prompt: "Reward runs that reach the correct CRM state."
  variance_threshold: 0.2
  uncertainty_threshold: 0.35

learning:
  llm:
    provider: openai
    model: gpt-4.1-mini
    api_key_env: OPENAI_API_KEY
    temperature: 0.05
    max_output_tokens: 2048
    timeout_seconds: 60
  history_limit: 5
  apply_to_prompts: false
  prompts:
    synthesizer: |
      Role: CRM learning synthesizer. Respond with ONLY valid JSON object (no markdown) containing:
      - student_pamphlet, teacher_pamphlet (string|null)
      - session_student_learning, session_teacher_learning (string|null)
      - playbook_entries: array of playbook_entry.v1 objects
      - metadata: object|null

      playbook_entry.v1 requirements:
      {
        "id": string|null,
        "audience": "student",
        "cue": {"type": "keyword"|"regex", "pattern": "<machine trigger>", "description": string|null},
        "action": {"imperative": "<<=120 chars>", "runtime_handle": "<handle from available_runtime_handles>", "tool_name": "<same>", "arguments": object|null},
        "expected_effect": "<<=200 chars>", 
        "scope": {"category": "reinforcement", "constraints": "<<=250 chars>", "applies_when": string|null},
        "metadata": object|null
      }

      Use only CRM harness handles (client_search, modify_client, upload_document, etc.). Avoid copying literal IDs, emails, timestamps, or one-off companies. Express arguments as templates (e.g., {"client_id": "<id>"}). If no safe entry exists, set playbook_entries to [] but still emit the full JSON object. Keep JSON strict (double quotes, no comments).
  schema:
    allowed_runtime_handles:
      - client_search
      - opportunity_search
      - quote_search
      - contract_search
      - contact_search
      - company_search
      - create_new_client
      - create_new_opportunity
      - create_contract
      - create_quote
      - create_new_contact
      - upload_document
      - add_note
      - modify_client
      - modify_opportunity
      - modify_quote
      - modify_contact
    cue_types:
      - keyword
      - regex
    default_scope_category: reinforcement
  gates:
    enforce_actionability: true
    enforce_cue: true
    enforce_generality: true
    max_text_length: 320
    allowed_proper_nouns:
      - CRM
      - Atlas
      - SQL
      - API
      - JSON
    banned_incident_tokens:
      - incident
      - ticket
      - case
      - postmortem
    allow_length_overflow_margin: 0
  usage_tracking:
    enabled: true
    capture_examples: true
    max_examples_per_entry: 3

storage:
  database_url: postgresql://atlas:atlas@localhost:5433/atlas
  min_connections: 1
  max_connections: 3
